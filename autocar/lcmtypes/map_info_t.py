"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

import lcmtypes.map_special_point_t

import lcmtypes.map_line_info_t

import lcmtypes.map_road_boundary_t

import lcmtypes.map_lane_info_t

class map_info_t(object):
    __slots__ = ["utime", "currentLaneIndex", "laneCount", "roadDirection", "thisSegmentType", "nextSegmentType", "distance2NextSegment", "nextSegmentSpeedLimited", "junctionType", "turnType", "distance2Junction", "speedLimited", "distance2LeftMarker", "distance2RightMarker", "distance2DecelerationStrip", "specialPointCount", "specialPoints", "boundaryCount", "boundary", "frontLineInfo", "backLineInfo", "frontLaneInfo", "backLaneInfo"]

    def __init__(self):
        self.utime = 0
        self.currentLaneIndex = 0
        self.laneCount = 0
        self.roadDirection = 0
        self.thisSegmentType = 0
        self.nextSegmentType = 0
        self.distance2NextSegment = 0.0
        self.nextSegmentSpeedLimited = 0.0
        self.junctionType = 0
        self.turnType = 0
        self.distance2Junction = 0.0
        self.speedLimited = 0.0
        self.distance2LeftMarker = 0.0
        self.distance2RightMarker = 0.0
        self.distance2DecelerationStrip = 0.0
        self.specialPointCount = 0
        self.specialPoints = []
        self.boundaryCount = 0
        self.boundary = []
        self.frontLineInfo = [ lcmtypes.map_line_info_t() for dim0 in range(4) ]
        self.backLineInfo = [ lcmtypes.map_line_info_t() for dim0 in range(4) ]
        self.frontLaneInfo = [ lcmtypes.map_lane_info_t() for dim0 in range(3) ]
        self.backLaneInfo = [ lcmtypes.map_lane_info_t() for dim0 in range(3) ]

    def encode(self):
        buf = BytesIO()
        buf.write(map_info_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qbbbbbffbbfffffh", self.utime, self.currentLaneIndex, self.laneCount, self.roadDirection, self.thisSegmentType, self.nextSegmentType, self.distance2NextSegment, self.nextSegmentSpeedLimited, self.junctionType, self.turnType, self.distance2Junction, self.speedLimited, self.distance2LeftMarker, self.distance2RightMarker, self.distance2DecelerationStrip, self.specialPointCount))
        for i0 in range(self.specialPointCount):
            assert self.specialPoints[i0]._get_packed_fingerprint() == lcmtypes.map_special_point_t._get_packed_fingerprint()
            self.specialPoints[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.boundaryCount))
        for i0 in range(self.boundaryCount):
            assert self.boundary[i0]._get_packed_fingerprint() == lcmtypes.map_road_boundary_t._get_packed_fingerprint()
            self.boundary[i0]._encode_one(buf)
        for i0 in range(4):
            assert self.frontLineInfo[i0]._get_packed_fingerprint() == lcmtypes.map_line_info_t._get_packed_fingerprint()
            self.frontLineInfo[i0]._encode_one(buf)
        for i0 in range(4):
            assert self.backLineInfo[i0]._get_packed_fingerprint() == lcmtypes.map_line_info_t._get_packed_fingerprint()
            self.backLineInfo[i0]._encode_one(buf)
        for i0 in range(3):
            assert self.frontLaneInfo[i0]._get_packed_fingerprint() == lcmtypes.map_lane_info_t._get_packed_fingerprint()
            self.frontLaneInfo[i0]._encode_one(buf)
        for i0 in range(3):
            assert self.backLaneInfo[i0]._get_packed_fingerprint() == lcmtypes.map_lane_info_t._get_packed_fingerprint()
            self.backLaneInfo[i0]._encode_one(buf)

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != map_info_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return map_info_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = map_info_t()
        self.utime, self.currentLaneIndex, self.laneCount, self.roadDirection, self.thisSegmentType, self.nextSegmentType, self.distance2NextSegment, self.nextSegmentSpeedLimited, self.junctionType, self.turnType, self.distance2Junction, self.speedLimited, self.distance2LeftMarker, self.distance2RightMarker, self.distance2DecelerationStrip, self.specialPointCount = struct.unpack(">qbbbbbffbbfffffh", buf.read(45))
        self.specialPoints = []
        for i0 in range(self.specialPointCount):
            self.specialPoints.append(lcmtypes.map_special_point_t._decode_one(buf))
        self.boundaryCount = struct.unpack(">h", buf.read(2))[0]
        self.boundary = []
        for i0 in range(self.boundaryCount):
            self.boundary.append(lcmtypes.map_road_boundary_t._decode_one(buf))
        self.frontLineInfo = []
        for i0 in range(4):
            self.frontLineInfo.append(lcmtypes.map_line_info_t._decode_one(buf))
        self.backLineInfo = []
        for i0 in range(4):
            self.backLineInfo.append(lcmtypes.map_line_info_t._decode_one(buf))
        self.frontLaneInfo = []
        for i0 in range(3):
            self.frontLaneInfo.append(lcmtypes.map_lane_info_t._decode_one(buf))
        self.backLaneInfo = []
        for i0 in range(3):
            self.backLaneInfo.append(lcmtypes.map_lane_info_t._decode_one(buf))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if map_info_t in parents: return 0
        newparents = parents + [map_info_t]
        tmphash = (0xac358940b03fadd2+ lcmtypes.map_special_point_t._get_hash_recursive(newparents)+ lcmtypes.map_road_boundary_t._get_hash_recursive(newparents)+ lcmtypes.map_line_info_t._get_hash_recursive(newparents)+ lcmtypes.map_line_info_t._get_hash_recursive(newparents)+ lcmtypes.map_lane_info_t._get_hash_recursive(newparents)+ lcmtypes.map_lane_info_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if map_info_t._packed_fingerprint is None:
            map_info_t._packed_fingerprint = struct.pack(">Q", map_info_t._get_hash_recursive([]))
        return map_info_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

